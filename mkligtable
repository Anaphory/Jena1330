#!/usr/bin/perl -w

use warnings;
use strict;

sub withvalue (&) { shift }
sub maphash (&@) {
    my ($keycb, $valcb, %hash) = @_;
    return
	map @$_,
	grep defined $_->[0],
	map [ $keycb->($_), $valcb->($hash{$_}) ],
	keys %hash;
}   

my %knowntable = (
    subst => {
	"'init' Initiale Formen in Latin lookup 2 subtable" => 'init',
#	"'medi' Medial Forms in Latin lookup 3 subtable"    => 'medi',  # TeX cannot deal with those
	"'fina' Wortendeformen in Latin lookup 5 subtable"  => 'fina',
	"Single Substitution lookup 0 subtable"             => 'lookbehind',
    },

    liga  => {
	"'liga' Standard Ligatures in Latin lookup 4 subtable" => 1,
    },

    kern  => {
	"'kern' Horizontales Kerning in Latin lookup 1 per glyph data 0" => 1,
    },

    lookbehind => {
	"'calt' Contextual Alternates in Latin lookup 1 subtable"
	    => "Single Substitution lookup 0"
    },
);

sub read_font {
    my ($fontdir) = @_;

    my %fontdata = (
	srcdir    => $fontdir,
	encoding  => my $encoding  = [ (undef) x 256 ],
	nametopos => my $nametopos = {},
	subst     => my $subst     = {},
	liga      => my $liga      = {},
	kern      => my $kern      = {},
	lbehind   =>                 {},
    );
    my (@lbbclass, @lbclass);

    open my $data, "$fontdir/font.props"
    	or die "Unable to open font properties file in `$fontdir' ($!).\n";

    my ($inchainsub, $lookup) = ('', undef);
    while (<$data>) {
	chomp;

	/^ChainSub2:(.*)$/ and do {
	    $inchainsub
		and die "Nested ChainSub2 declaration in `$fontdir'.\n";
	    my ($type, $table) = $1 =~ /(\S+)\s+"([^"]*)"[\s\d]*$/
		or die "Unexpected ChainSub2 declaration in `$fontdir'.\n";
	    defined($lookup = $knowntable{lookbehind}{$table})
		or die "Unknown lookbehind table `$table'.\n";
	    $inchainsub = 1;
	}, next;

	/^EndFPST\s*$/ and do {
	    # FIXME eintragen
	    $inchainsub = 0;
	}, next;

	$inchainsub or next;

	/^\s*Class:(.*)$/  and ( (undef, @lbclass)  = split " ", $1 ), next;
	/^\s*BClass:(.*)$/ and ( (undef, @lbbclass) = split " ", $1 ), next;

	/^\s*(B|F|)ClsList:\s*(.*?)\s*$/ and do {
	       ($1 eq ''  && $2 eq '1')
	    || ($1 eq 'B' && $2 eq '1')
	    || ($1 eq 'F' && $2 eq '')
		or die "Unknown lookbehind substitution.\n";
	}, next;   

	/^\s*SeqLookup:\s*(.*?)\s*$/ and do {
	    (my $cur = $1) =~ s/^\s*\d+\s+"([^"]*)"/$1/
		or die "Invalid SeqLookup syntax in `$fontdir'.\n";
	    $cur ne $lookup 
		and die "Unknown lookbehind subsitution table `$cur' specified.\n";
	}, next;
    }

    close $data;

    opendir my $dir, $fontdir
	or die "Unable to open font directory `$fontdir' ($!).\n";

    while (my $glyphname = readdir $dir) {
	$glyphname =~ /^\./ and next;
	$glyphname =~ /\.glyph$/ or next;

	open my $glyph, "$fontdir/$glyphname"
	    or die "Error opening glyph `$fontdir/$glyphname' ($!).\n";

	my $die = sub { die "Error in glyphfile `$fontdir/$glyphname' (@_).\n" };

	my ($name, $pos);
	while (<$glyph>) {
	    chomp;
	    /^\s*$/ and next;

	    /^StartChar:\s*(\S*)\s*$/ and do {
		defined $name and $die->("duplicate StartChar");
		$name = $1;
	    }, next;

	    defined $name or $die->("garbage before StartChar");

	    /^Encoding:(.*)$/ and do {
		(my $positions = $1) =~ /^\s*[-\d]+\s+[-\d]+\s+[-\d]+\s*$/
		    or $die->("unexpected Encoding specification `$1'");

		($pos, undef, undef) = split " ", $positions;
		$pos < 0 || $pos > 255 and next;

		defined $encoding->[$pos]
		    and $die->("position `$pos' already taken by `$encoding->[$pos]'");
		$encoding->[$pos] = $name;
		$nametopos->{$name} = $pos;
	    }, next;

	    /^Substitution2:(.*)$/ and do {
		my ($table, $newform) = ($1 =~ /^\s*"([^"]*)"\s*(\S+)\s*$/)
		    or $die->("substitution `$1' not parseable");
		$table = $knowntable{subst}{$table}
		    or $die->("unknown substitution table \"$table\"");
		defined $subst->{$table}->{$pos}
		    and $die->("duplicate substition for table \"$table\"");
		$subst->{$table}->{$pos} = $newform;
	    }, next;

	    /^Ligature2:(.*)$/ and do {
		my ($table, $first, $second) = ($1 =~ /^\s*"([^"]*)"\s*(\S+)\s+(\S+)\s*$/)
		    or $die->("ligature pair `$1' not parseable");
		$knowntable{liga}{$table}
		    or $die->("unknown ligature table \"$table\"");
		defined $liga->{$first}->{$second} && 
		    $liga->{$first}->{$second} ne $name
		        and $die->("duplicate ligature");
		$liga->{$first}->{$second} = $name;
	    }, next;

	    /^Kerns2:(.*)$/ and do {
		local $_ = $1;
		while (!/^\s*$/) {
		    s/^\s*(\d+)\s+([-\d]+)\s+"([^"]*)"//
			or $die->("unparseable kern spec `$_'");
		    $knowntable{kern}{$3}
			or $die->("unknown kerning table \"$3\"");
		    $2 == 0 and next;
		    defined $kern->{$pos}->{$1}
			and $die->("duplicate kern spec for pos $1");
		    $kern->{$pos}->{$1} = $2;
		}
	    }, next;

	}

	close $glyph;
    }

    closedir $dir;

    # We need positions, not names, but due do possible forward
    # references we need a second pass.

    @$_{keys %$_} = map $nametopos->{$_}, values %$_
	for values %$subst;

    my %newliga = 
	maphash { $nametopos->{+shift} } withvalue {
	    +{ maphash { $nametopos->{+shift} } 
		   withvalue { $nametopos->{+shift} }, 
	           %{+shift} }},
	%$liga;   

    my %lookbehindsubst =
	map { $_ => $subst->{lookbehind}->{$_} }
	grep defined,
	map $nametopos->{$_}, @lbclass;
    $fontdata{lbehind}->{$_} = \%lookbehindsubst
	for grep defined, map $nametopos->{$_}, @lbbclass;
    delete $subst->{lookbehind};

    $fontdata{liga} = \%newliga;
    return \%fontdata;
}

sub write_ligtable {
    my ($out, $fontdata) = @_;

    my $encoding = $fontdata->{encoding};
    my $subst    = $fontdata->{subst};
        my $init = $subst->{init};
	my $fina = $subst->{fina};
    my $liga     = $fontdata->{liga};
    my $kern     = $fontdata->{kern};
    my $look     = $fontdata->{lbehind};

    # FIXME BOUNDARYCHAR ligatures müssen auch für ([' etc definiert sein!

    my $bpos = 0;
    $bpos++ while defined $encoding->[$bpos];
    $bpos > 255 and die "Cannot find boundary character (all slots taken).\n";

    printf $out "(BOUNDARYCHAR O %o)\n", $bpos;
    print  $out "(LIGTABLE\n";
    print  $out "   (LABEL BOUNDARYCHAR)\n";
    printf $out "   (LIG O %o O %o)\n", $_, $init->{$_} for keys %$init;
    print  $out "   (STOP)\n";

    foreach my $pos (0..255) {
	my $kern = $kern->{$pos} // {};
	my $look = $look->{$pos} // {};
	my $fina = $fina->{$pos};
	keys %$kern || keys %$look || defined $fina or next;

	printf $out "   (LABEL O %o)\n", $pos;
	printf $out "   (LIG O %o O %o)\n", $bpos, $fina
	    if defined $fina;
	printf $out "   (/LIG O %o O %o)\n", $_, $look->{$_}
	    for keys %$look;
	printf $out "   (KRN O %o R %g)\n", $_, $kern->{$_}/1000
	    for keys %$kern;
	printf $out "   (STOP)\n";

    }

    print  $out "   )\n";
}

#
# main
#

#use Data::Dumper;
#print Data::Dumper::Dumper read_font shift;
#exit;

my ($fontdir) = @ARGV
    or die "Usage: mkligtable fontdir/\n";

write_ligtable \*STDOUT, read_font $fontdir;

# vim:ft=perl:sts=4:sw=4
